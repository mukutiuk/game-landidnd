{"mappings":"A,S,E,C,C,C,E,C,A,M,G,E,E,M,A,G,C,E,E,M,A,E,I,I,E,E,E,A,M,G,E,E,I,C,C,E,C,C,C,E,C,O,C,C,S,E,C,E,O,A,S,C,E,G,M,O,C,G,O,E,E,E,I,A,S,C,E,G,A,a,O,Q,A,M,C,C,O,Q,C,E,A,M,C,C,a,C,O,M,I,C,E,E,I,A,S,C,C,C,E,G,G,G,A,U,O,E,O,E,E,K,G,I,E,O,S,C,Q,C,I,C,G,K,C,E,I,G,W,G,E,W,E,C,E,E,W,C,I,A,E,A,Q,G,A,Q,E,O,M,I,C,G,G,A,c,G,2C,I,C,G,O,E,E,K,G,E,I,A,W,M,A,U,wI,G,CCOA,IAAM,EAAO,SAAS,aAAa,CAAC,eAC9B,EAAQ,SAAS,aAAa,CAAC,eAC/B,EAAc,SAAS,aAAa,CAAC,UACrC,EAAe,SAAS,aAAa,CAAC,kBACtC,EAAS,SAAS,aAAa,CAAC,gBAChC,EAAO,SAAS,aAAa,CAAC,iBAChC,EAAa,EACb,EAAQ,EAAE,CAEV,EAAS,CACX,CAAC,EAAG,EAAG,EAAG,EAAE,CACZ,CAAC,EAAG,EAAG,EAAG,EAAE,CACZ,CAAC,EAAG,EAAG,EAAG,EAAE,CACZ,CAAC,EAAG,EAAG,EAAG,EAAE,CACb,CAmCD,SAAS,IAGP,IAAK,IAFD,EAAO,UAEF,EAAI,EAAG,EAAI,EAAO,MAAM,CAAE,IAAK,CACtC,GAAS,yBAET,IAAK,IAAI,EAAI,EAAG,EAAI,CAAM,CAAC,EAAE,CAAC,MAAM,CAAE,IACpC,GAAS,4CACsB,MAAA,CAAjB,CAAM,CAAC,EAAE,CAAC,EAAE,CAAC,MAAuB,MAAA,CAAnB,CAAM,CAAC,EAAE,CAAC,EAAE,EAAI,GAAG,SAEpD,GAAQ,OACV,CAEA,GAAQ,WACR,EAAK,SAAS,CAAG,EACjB,EAAM,SAAS,CAAG,CACpB,CAEA,SAAS,IACP,IAAK,IAAI,EAAI,EAAG,EAAI,EAAO,MAAM,CAAE,IACjC,IAAK,IAAI,EAAI,EAAG,EAAI,CAAM,CAAC,EAAE,CAAC,MAAM,CAAE,IACpC,EAAM,IAAI,CAAC,CACT,EAAG,EACH,EAAG,EACH,QAAS,CAAA,CACX,EAGN,CAIA,SAAS,IACP,IAAiB,EAAA,AAgInB,WACE,IAAM,EAAa,EAAM,MAAM,CAAC,SAAhC,CAAA,EAAiD,OAAd,EAAA,OAAA,A,GAEnC,GAAI,EAAW,MAAM,CAAE,CACrB,IAAM,EAAc,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAW,MAAM,EAEhE,OAAO,CAAU,CAAC,EAAY,AAChC,CACF,IAxIU,EAAS,EAAT,CAAA,CAAG,EAAM,EAAN,CAAX,CAEA,EAAQ,EAAM,GAAG,CAAC,SAAA,CAAlB,EACE,GAAI,EAAK,CAAC,GAAK,GAAK,EAAK,CAAC,GAAK,EAC7B,K,E,EAAA,O,EAAQ,A,S,C,E,I,I,E,E,E,U,M,C,I,C,I,E,A,M,S,C,E,C,S,C,E,C,C,E,E,O,I,C,E,C,Y,O,O,qB,E,C,E,E,M,C,O,qB,C,G,M,C,S,C,E,O,O,wB,C,E,G,U,A,G,E,E,O,C,S,C,M,E,E,C,C,E,C,A,K,E,O,c,C,E,E,C,M,E,W,C,E,a,C,E,S,C,C,G,A,C,C,E,C,C,E,C,O,C,EAAA,CAAA,EACH,G,E,EAFP,CAGI,QAAS,CAAA,C,E,O,yB,C,O,gB,C,E,O,yB,C,I,A,C,S,C,C,C,E,I,E,O,I,C,G,G,O,qB,C,C,I,E,O,qB,C,G,E,I,C,K,C,E,E,C,O,C,C,E,O,I,O,C,S,C,E,O,c,C,E,E,O,wB,C,E,G,G,C,CAIb,OAAO,CACT,GAEA,CAAM,CAAC,EAAE,CAAC,EAAE,CAjDL,KAAK,MAAM,GAAK,GAAM,EAAI,EAmDjC,IAAM,EAAU,EACb,GAAG,CAAC,SAAS,CAAG,EACf,OAAO,KAAK,GAAG,CAAC,KAAK,CAAC,KAAM,EAC9B,GAEmB,KAAK,GAAG,CAAC,KAAK,CAAC,KAAM,IAEtB,MAClB,EAAO,SAAS,CAAC,MAAM,CAAC,SAE5B,CAEA,SAAS,IACP,OAAO,gBAAgB,CAAC,UAAW,EAAa,CAAE,KAAM,CAAA,CAAK,EAC/D,CAEA,SAAS,EAAY,CAAM,EACzB,OAAQ,EAAO,GAAG,EAChB,IAxHa,UAyHX,GAAI,CAkKD,EAFQ,KA/JT,OAAO,IA4Db,EAFmB,KAtDf,KAEF,KA/He,YAgIb,GAAI,CAAC,IACH,OAAO,IA6Db,EAH+B,AAFZ,IAGhB,GAAG,CAAC,SAAA,CADP,EACgB,OAAC,EAAG,GAAO,OAAO,E,IAvD9B,KAEF,KAtIgB,aAuId,GAAI,CAAC,IACH,OAAO,IAoEb,EAH6B,AAFV,IAGhB,GAAG,CAAC,SAAA,CADP,EACc,OAAC,EAAG,GAAK,OAAO,E,IA9D1B,KAEF,KA7Ie,YA8Ib,GAAI,CAkKD,EAFQ,KA/JT,OAAO,IAmDb,EAFmB,IA5CnB,CACA,IAmIO,EAFQ,MA/HM,KAyJd,EAFQ,MAvJ0C,KACvD,EAAK,SAAS,CAAC,MAAM,CAAC,UAGxB,GACF,CAEA,SAAS,IACP,OAAO,EAAM,MAAM,CAAC,SAAC,CAAA,CAAU,CAA/B,EAIE,OAHA,CAAQ,CAAC,EAAK,CAAC,CAAC,CAAG,CAAQ,CAAC,EAAK,CAAC,CAAC,EAAI,EAAE,CACzC,CAAQ,CAAC,EAAK,CAAC,CAAC,CAAC,EAAK,CAAC,CAAC,CAAG,EAEpB,CACT,EAAG,EAAE,CACP,CAEA,SAAS,IACP,OAAO,EAAM,MAAM,CAAC,SAAC,CAAA,CAAU,CAA/B,EAIE,OAHA,CAAQ,CAAC,EAAK,CAAC,CAAC,CAAG,CAAQ,CAAC,EAAK,CAAC,CAAC,EAAI,EAAE,CACzC,CAAQ,CAAC,EAAK,CAAC,CAAC,CAAC,EAAK,CAAC,CAAC,CAAG,EAEpB,CACT,EAAG,EAAE,CACP,CAkCA,SAAS,EAAW,CAAS,EAC3B,EAAU,OAAO,CAAC,SAAA,CAAlB,EAA6B,OAAA,AAa/B,SAA4B,CAAK,EAC/B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAChC,GAAI,AAAqB,CAAA,IAArB,CAAK,CAAC,EAAE,CAAC,OAAO,EASpB,IALA,IAAM,EAAgB,CAAK,CAAC,EAAE,CAE1B,EAAA,KAAA,EACA,EAAI,EAAI,EAEL,GAAK,GACF,CAAA,AAAqB,CAAA,IAArB,CAAK,CAAC,EAAE,CAAC,OAAO,EACjB,EAAe,CAAK,CAAC,EAAE,CAAE,EAAA,GAC5B,EAAe,CAAK,CAAC,EAAE,CAAE,IAC3B,CAAA,GAAc,AAA2C,EAA3C,CAAM,CAAC,EAAc,CAAC,CAAC,CAAC,EAAc,CAAC,CAAC,AAAG,EAG3D,EAAa,CAAK,CAAC,EAAE,CAErB,IAGF,IAAM,EAAY,CAAM,CAAC,EAAc,CAAC,CAAC,CAAC,EAAc,CAAC,CAAC,CAErD,IAIL,CAAM,CAAC,EAAc,CAAC,CAAC,CAAC,EAAc,CAAC,CAAC,CAAG,EAE3C,AAQJ,SAAiC,CAAa,CAAE,CAAU,EACnD,IAAA,EAAA,CAAA,EAAA,EAAA,CAAA,EAAA,EAAA,KAAA,E,G,CAAL,IAAA,IAAK,EAAA,EAAc,CAAA,CAAA,OAAA,QAAA,CAAA,GAAd,CAAA,CAAA,EAAA,AAAA,CAAA,EAAA,EAAA,IAAA,EAAA,EAAA,IAAA,AAAA,EAAA,EAAA,CAAA,EAAqB,CAArB,IAAM,EAAN,EAAA,KAAA,AACC,CAAA,EAAK,CAAC,GAAK,EAAW,CAAC,EAAI,EAAK,CAAC,GAAK,EAAW,CAAC,EACpD,CAAA,EAAK,OAAO,CAAG,CAAA,CADjB,EAII,EAAK,CAAC,GAAK,EAAc,CAAC,EAAI,EAAK,CAAC,GAAK,EAAc,CAAC,EAC1D,CAAA,EAAK,OAAO,CAAG,CAAA,CADjB,CAGF,C,C,M,E,CARK,EAAA,CAAA,EAAA,EAAA,C,Q,C,G,CAAA,GAAA,AAAA,MAAA,EAAA,MAAA,EAAA,EAAA,MAAA,E,Q,CAAA,GAAA,EAAA,MAAA,C,C,CASP,EAlB4B,EAAe,GAEvC,CAAM,CAAC,EAAW,CAAC,CAAC,CAAC,EAAW,CAAC,CAAC,EAAI,EAEtC,KAEJ,EAlDkD,E,EAClD,CA+DA,SAAS,EAAe,CAAI,CAAE,CAAa,EACzC,OAAO,CAAM,CAAC,EAAK,CAAC,CAAC,CAAC,EAAK,CAAC,CAAC,GAAK,CAAM,CAAC,EAAc,CAAC,CAAC,CAAC,EAAc,CAAC,CAAC,AAC5E,CAQA,SAAS,IAMP,OAAO,EAHwB,AAFZ,IAGhB,GAAG,CAAC,SAAA,CADP,EACgB,OAAC,EAAG,GAAO,OAAO,E,GAGpC,CAEA,SAAS,IAMP,OAAO,EAHsB,AAFV,IAGhB,GAAG,CAAC,SAAA,CADP,EACc,OAAC,EAAG,GAAK,OAAO,E,GAGhC,CAQA,SAAS,EAAQ,CAAM,EACrB,OAAO,EAAO,IAAI,CAAC,SAAA,CAAnB,EAA4B,OAIrB,AAJoC,EAI9B,IAAI,CAAC,SAAC,CAAA,CAAM,CAAzB,EACE,GAAc,IAAV,GAIA,AAAiB,CAAA,IAAjB,EAAK,OAAO,CAHd,MAAO,CAAA,EAOT,IAAM,EAAa,AAbsB,CAajB,CAAC,EAAQ,EAAE,CAInC,OAFA,IAEO,AAAuB,CAAA,IAAvB,EAAW,OAAO,EACpB,EAAe,EAAM,EAC5B,E,EAlBF,CAnSA,EAAY,gBAAgB,CAAC,QAAS,SAAC,CAAvC,EACE,EAAa,SAAS,CAAC,GAAG,CAAC,UAC3B,EAAK,SAAS,CAAC,GAAG,CAAC,UAEf,EAAY,SAAS,CAAC,QAAQ,CAAC,WACjC,EAAY,SAAS,CAAC,OAAO,CAAC,QAAS,WACvC,EAAY,SAAS,CAAG,UAExB,EAAO,SAAS,CAAC,GAAG,CAAC,WAGvB,EAAa,EACb,EAAQ,EAAE,CACV,IAEA,EAAS,CACP,CAAC,EAAG,EAAG,EAAG,EAAE,CACZ,CAAC,EAAG,EAAG,EAAG,EAAE,CACZ,CAAC,EAAG,EAAG,EAAG,EAAE,CACZ,CAAC,EAAG,EAAG,EAAG,EAAE,CACb,CACD,IACA,IAEA,SAAS,gBAAgB,CAAC,UAAW,GAErC,GACF,GAoCA","sources":["<anon>","src/scripts/main.js"],"sourcesContent":["\"use strict\";\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array(arr);\n}\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _object_spread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _object_spread_props(target, source) {\n    source = source != null ? source : {};\n    if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n        ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nvar ARROW_UP = \"ArrowUp\";\nvar ARROW_DOWN = \"ArrowDown\";\nvar ARROW_RIGHT = \"ArrowRight\";\nvar ARROW_LEFT = \"ArrowLeft\";\nvar game = document.querySelector(\".game-field\");\nvar score = document.querySelector(\".game-score\");\nvar buttonStart = document.querySelector(\".start\");\nvar messageStart = document.querySelector(\".message-start\");\nvar winner = document.querySelector(\".message-win\");\nvar lose = document.querySelector(\".message-lose\");\nvar scoreCount = 0;\nvar cells = [];\nvar matrix = [\n    [\n        0,\n        0,\n        0,\n        0\n    ],\n    [\n        0,\n        0,\n        0,\n        0\n    ],\n    [\n        0,\n        0,\n        0,\n        0\n    ],\n    [\n        0,\n        0,\n        0,\n        0\n    ]\n];\nbuttonStart.addEventListener(\"click\", function(e) {\n    messageStart.classList.add(\"hidden\");\n    lose.classList.add(\"hidden\");\n    if (buttonStart.classList.contains(\"start\")) {\n        buttonStart.classList.replace(\"start\", \"restart\");\n        buttonStart.innerText = \"Restart\";\n        winner.classList.add(\"hidden\");\n    }\n    scoreCount = 0;\n    cells = [];\n    cellsGroup();\n    matrix = [\n        [\n            0,\n            0,\n            0,\n            0\n        ],\n        [\n            0,\n            0,\n            0,\n            0\n        ],\n        [\n            0,\n            0,\n            0,\n            0\n        ],\n        [\n            0,\n            0,\n            0,\n            0\n        ]\n    ];\n    setRandomCell();\n    setRandomCell();\n    document.addEventListener(\"keydown\", handleInput);\n    setDataToTable();\n});\nfunction getVelue() {\n    return Math.random() > 0.9 ? 4 : 2;\n}\nfunction setDataToTable() {\n    var data = \"<tbody>\";\n    for(var i = 0; i < matrix.length; i++){\n        data += '<tr class=\"field-row\">';\n        for(var j = 0; j < matrix[i].length; j++)data += '<td class=\"field-cell\\n      field-cell--'.concat(matrix[i][j], '\">').concat(matrix[i][j] || \"\", \"</td>\");\n        data += \"</tr>\";\n    }\n    data += \"</tbody>\";\n    game.innerHTML = data;\n    score.innerText = scoreCount;\n}\nfunction cellsGroup() {\n    for(var i = 0; i < matrix.length; i++)for(var j = 0; j < matrix[i].length; j++)cells.push({\n        x: i,\n        y: j,\n        isEmpty: true\n    });\n}\ncellsGroup();\nfunction setRandomCell() {\n    var _getRandomEmptyCell = getRandomEmptyCell(), x = _getRandomEmptyCell.x, y = _getRandomEmptyCell.y;\n    cells = cells.map(function(tile) {\n        if (tile.x === x && tile.y === y) return _object_spread_props(_object_spread({}, tile), {\n            isEmpty: false\n        });\n        return tile;\n    });\n    matrix[x][y] = getVelue();\n    var maxCell = matrix.map(function(row) {\n        return Math.max.apply(Math, row);\n    });\n    var maxCellValue = Math.max.apply(null, maxCell);\n    if (maxCellValue >= 2048) winner.classList.remove(\"hidden\");\n}\nfunction setupInputOnce() {\n    window.addEventListener(\"keydown\", handleInput, {\n        once: true\n    });\n}\nfunction handleInput(events) {\n    switch(events.key){\n        case ARROW_UP:\n            if (!canMuveUp()) return setupInputOnce();\n            moveUp();\n            break;\n        case ARROW_DOWN:\n            if (!canMuveDown()) return setupInputOnce();\n            moveDown();\n            break;\n        case ARROW_RIGHT:\n            if (!canMuveRigth()) return setupInputOnce();\n            moveRigth();\n            break;\n        case ARROW_LEFT:\n            if (!canMuveLeft()) return setupInputOnce();\n            moveLeft();\n            break;\n    }\n    setRandomCell();\n    if (!canMuveUp() && !canMuveDown() && !canMuveLeft() && !canMuveRigth()) lose.classList.remove(\"hidden\");\n    setDataToTable();\n}\nfunction groupCellsColum() {\n    return cells.reduce(function(acumCels, cell) {\n        acumCels[cell.y] = acumCels[cell.y] || [];\n        acumCels[cell.y][cell.x] = cell;\n        return acumCels;\n    }, []);\n}\nfunction groupCellsRow() {\n    return cells.reduce(function(acumCels, cell) {\n        acumCels[cell.x] = acumCels[cell.x] || [];\n        acumCels[cell.x][cell.y] = cell;\n        return acumCels;\n    }, []);\n}\nfunction moveUp() {\n    var groupCells = groupCellsColum();\n    sliderTile(groupCells);\n}\nfunction moveDown() {\n    var groupCells = groupCellsColum();\n    var groupCellsColumReverse = groupCells.map(function(colum) {\n        return _to_consumable_array(colum).reverse();\n    });\n    sliderTile(groupCellsColumReverse);\n}\nfunction moveLeft() {\n    var groupCells = groupCellsRow();\n    sliderTile(groupCells);\n}\nfunction moveRigth() {\n    var groupCells = groupCellsRow();\n    var groupCellsRowReverse = groupCells.map(function(row) {\n        return _to_consumable_array(row).reverse();\n    });\n    sliderTile(groupCellsRowReverse);\n    return groupCellsRowReverse;\n}\nfunction sliderTile(groupCell) {\n    groupCell.forEach(function(element) {\n        return sliderCellsInGroup(element);\n    });\n}\nfunction getRandomEmptyCell() {\n    var emptyCells = cells.filter(function(param) {\n        var isEmpty = param.isEmpty;\n        return isEmpty;\n    });\n    if (emptyCells.length) {\n        var randomIndex = Math.floor(Math.random() * emptyCells.length);\n        return emptyCells[randomIndex];\n    }\n}\nfunction sliderCellsInGroup(group) {\n    for(var i = 0; i < group.length; i++){\n        if (group[i].isEmpty === true) continue;\n        var cellWithVelue = group[i];\n        var targetCell = void 0;\n        var j = i - 1;\n        while(j >= 0 && (group[j].isEmpty === true || isEmptyForMerg(group[j], cellWithVelue))){\n            if (isEmptyForMerg(group[j], cellWithVelue)) scoreCount += matrix[cellWithVelue.x][cellWithVelue.y] * 2;\n            targetCell = group[j];\n            j--;\n        }\n        var prevValue = matrix[cellWithVelue.x][cellWithVelue.y];\n        if (!targetCell) continue;\n        matrix[cellWithVelue.x][cellWithVelue.y] = 0;\n        replacementIsEmptyValue(cellWithVelue, targetCell);\n        matrix[targetCell.x][targetCell.y] += prevValue;\n        setDataToTable();\n    }\n}\nfunction replacementIsEmptyValue(cellWithVelue, targetCell) {\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        for(var _iterator = cells[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var tile = _step.value;\n            if (tile.x === targetCell.x && tile.y === targetCell.y) tile.isEmpty = false;\n            if (tile.x === cellWithVelue.x && tile.y === cellWithVelue.y) tile.isEmpty = true;\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n}\nfunction isEmptyForMerg(tile, cellWithVelue) {\n    return matrix[tile.x][tile.y] === matrix[cellWithVelue.x][cellWithVelue.y];\n}\nfunction canMuveUp() {\n    var groups = groupCellsColum();\n    return canMuve(groups);\n}\nfunction canMuveDown() {\n    var groupCells = groupCellsColum();\n    var groupCellsColumReverse = groupCells.map(function(colum) {\n        return _to_consumable_array(colum).reverse();\n    });\n    return canMuve(groupCellsColumReverse);\n}\nfunction canMuveRigth() {\n    var groupCells = groupCellsRow();\n    var groupCellsRowReverse = groupCells.map(function(row) {\n        return _to_consumable_array(row).reverse();\n    });\n    return canMuve(groupCellsRowReverse);\n}\nfunction canMuveLeft() {\n    var groups = groupCellsRow();\n    return canMuve(groups);\n}\nfunction canMuve(groups) {\n    return groups.some(function(group) {\n        return canMuveInGroup(group);\n    });\n}\nfunction canMuveInGroup(group) {\n    return group.some(function(cell, index) {\n        if (index === 0) return false;\n        if (cell.isEmpty === true) return false;\n        var targetCell = group[index - 1];\n        setDataToTable();\n        return targetCell.isEmpty === true || isEmptyForMerg(cell, targetCell);\n    });\n}\n\n//# sourceMappingURL=index.ba7adca1.js.map\n","'use strict';\n\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_RIGHT = 'ArrowRight';\nconst ARROW_LEFT = 'ArrowLeft';\n\nconst game = document.querySelector('.game-field');\nconst score = document.querySelector('.game-score');\nconst buttonStart = document.querySelector('.start');\nconst messageStart = document.querySelector('.message-start');\nconst winner = document.querySelector('.message-win');\nconst lose = document.querySelector('.message-lose');\nlet scoreCount = 0;\nlet cells = [];\n\nlet matrix = [\n  [0, 0, 0, 0],\n  [0, 0, 0, 0],\n  [0, 0, 0, 0],\n  [0, 0, 0, 0],\n];\n\nbuttonStart.addEventListener('click', (e) => {\n  messageStart.classList.add('hidden');\n  lose.classList.add('hidden');\n\n  if (buttonStart.classList.contains('start')) {\n    buttonStart.classList.replace('start', 'restart');\n    buttonStart.innerText = 'Restart';\n\n    winner.classList.add('hidden');\n  }\n\n  scoreCount = 0;\n  cells = [];\n  cellsGroup();\n\n  matrix = [\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n  ];\n  setRandomCell();\n  setRandomCell();\n\n  document.addEventListener('keydown', handleInput);\n\n  setDataToTable();\n});\n\nfunction getVelue() {\n  return Math.random() > 0.9 ? 4 : 2;\n}\n\nfunction setDataToTable() {\n  let data = '<tbody>';\n\n  for (let i = 0; i < matrix.length; i++) {\n    data += `<tr class=\"field-row\">`;\n\n    for (let j = 0; j < matrix[i].length; j++) {\n      data += `<td class=\"field-cell\n      field-cell--${matrix[i][j]}\">${matrix[i][j] || ''}</td>`;\n    }\n    data += '</tr>';\n  }\n\n  data += '</tbody>';\n  game.innerHTML = data;\n  score.innerText = scoreCount;\n}\n\nfunction cellsGroup() {\n  for (let i = 0; i < matrix.length; i++) {\n    for (let j = 0; j < matrix[i].length; j++) {\n      cells.push({\n        x: i,\n        y: j,\n        isEmpty: true,\n      });\n    }\n  }\n}\n\ncellsGroup();\n\nfunction setRandomCell() {\n  const { x, y } = getRandomEmptyCell();\n\n  cells = cells.map(tile => {\n    if (tile.x === x && tile.y === y) {\n      return ({\n        ...tile,\n        isEmpty: false,\n      });\n    }\n\n    return tile;\n  });\n\n  matrix[x][y] = getVelue();\n\n  const maxCell = matrix\n    .map(function(row) {\n      return Math.max.apply(Math, row);\n    });\n\n  const maxCellValue = Math.max.apply(null, maxCell);\n\n  if (maxCellValue >= 2048) {\n    winner.classList.remove('hidden');\n  }\n}\n\nfunction setupInputOnce() {\n  window.addEventListener('keydown', handleInput, { once: true });\n}\n\nfunction handleInput(events) {\n  switch (events.key) {\n    case ARROW_UP:\n      if (!canMuveUp()) {\n        return setupInputOnce();\n      }\n\n      moveUp();\n      break;\n\n    case ARROW_DOWN:\n      if (!canMuveDown()) {\n        return setupInputOnce();\n      }\n\n      moveDown();\n      break;\n\n    case ARROW_RIGHT:\n      if (!canMuveRigth()) {\n        return setupInputOnce();\n      }\n\n      moveRigth();\n      break;\n\n    case ARROW_LEFT:\n      if (!canMuveLeft()) {\n        return setupInputOnce();\n      }\n\n      moveLeft();\n      break;\n  }\n  setRandomCell();\n\n  if (!canMuveUp() && !canMuveDown() && !canMuveLeft() && !canMuveRigth()) {\n    lose.classList.remove('hidden');\n  }\n\n  setDataToTable();\n}\n\nfunction groupCellsColum() {\n  return cells.reduce((acumCels, cell) => {\n    acumCels[cell.y] = acumCels[cell.y] || [];\n    acumCels[cell.y][cell.x] = cell;\n\n    return acumCels;\n  }, []);\n}\n\nfunction groupCellsRow() {\n  return cells.reduce((acumCels, cell) => {\n    acumCels[cell.x] = acumCels[cell.x] || [];\n    acumCels[cell.x][cell.y] = cell;\n\n    return acumCels;\n  }, []);\n}\n\nfunction moveUp() {\n  const groupCells = groupCellsColum();\n\n  sliderTile(groupCells);\n}\n\nfunction moveDown() {\n  const groupCells = groupCellsColum();\n\n  const groupCellsColumReverse = groupCells\n    .map(colum => [...colum].reverse());\n\n  sliderTile(groupCellsColumReverse);\n}\n\nfunction moveLeft() {\n  const groupCells = groupCellsRow();\n\n  sliderTile(groupCells);\n}\n\nfunction moveRigth() {\n  const groupCells = groupCellsRow();\n\n  const groupCellsRowReverse = groupCells\n    .map(row => [...row].reverse());\n\n  sliderTile(groupCellsRowReverse);\n\n  return groupCellsRowReverse;\n}\n\nfunction sliderTile(groupCell) {\n  groupCell.forEach(element => sliderCellsInGroup(element));\n}\n\nfunction getRandomEmptyCell() {\n  const emptyCells = cells.filter(({ isEmpty }) => isEmpty);\n\n  if (emptyCells.length) {\n    const randomIndex = Math.floor(Math.random() * emptyCells.length);\n\n    return emptyCells[randomIndex];\n  }\n}\n\nfunction sliderCellsInGroup(group) {\n  for (let i = 0; i < group.length; i++) {\n    if (group[i].isEmpty === true) {\n      continue;\n    }\n\n    const cellWithVelue = group[i];\n\n    let targetCell;\n    let j = i - 1;\n\n    while (j >= 0\n          && (group[j].isEmpty === true\n          || isEmptyForMerg(group[j], cellWithVelue))) {\n      if (isEmptyForMerg(group[j], cellWithVelue)) {\n        scoreCount += matrix[cellWithVelue.x][cellWithVelue.y] * 2;\n      }\n\n      targetCell = group[j];\n\n      j--;\n    }\n\n    const prevValue = matrix[cellWithVelue.x][cellWithVelue.y];\n\n    if (!targetCell) {\n      continue;\n    }\n\n    matrix[cellWithVelue.x][cellWithVelue.y] = 0;\n\n    replacementIsEmptyValue(cellWithVelue, targetCell);\n\n    matrix[targetCell.x][targetCell.y] += prevValue;\n\n    setDataToTable();\n  }\n}\n\nfunction replacementIsEmptyValue(cellWithVelue, targetCell) {\n  for (const tile of cells) {\n    if (tile.x === targetCell.x && tile.y === targetCell.y) {\n      tile.isEmpty = false;\n    }\n\n    if (tile.x === cellWithVelue.x && tile.y === cellWithVelue.y) {\n      tile.isEmpty = true;\n    }\n  }\n}\n\nfunction isEmptyForMerg(tile, cellWithVelue) {\n  return matrix[tile.x][tile.y] === matrix[cellWithVelue.x][cellWithVelue.y];\n}\n\nfunction canMuveUp() {\n  const groups = groupCellsColum();\n\n  return canMuve(groups);\n}\n\nfunction canMuveDown() {\n  const groupCells = groupCellsColum();\n\n  const groupCellsColumReverse = groupCells\n    .map(colum => [...colum].reverse());\n\n  return canMuve(groupCellsColumReverse);\n}\n\nfunction canMuveRigth() {\n  const groupCells = groupCellsRow();\n\n  const groupCellsRowReverse = groupCells\n    .map(row => [...row].reverse());\n\n  return canMuve(groupCellsRowReverse);\n}\n\nfunction canMuveLeft() {\n  const groups = groupCellsRow();\n\n  return canMuve(groups);\n}\n\nfunction canMuve(groups) {\n  return groups.some(group => canMuveInGroup(group));\n}\n\nfunction canMuveInGroup(group) {\n  return group.some((cell, index) => {\n    if (index === 0) {\n      return false;\n    }\n\n    if (cell.isEmpty === true) {\n      return false;\n    }\n\n    const targetCell = group[index - 1];\n\n    setDataToTable();\n\n    return targetCell.isEmpty === true\n      || isEmptyForMerg(cell, targetCell);\n  });\n}\n"],"names":["_array_like_to_array","arr","len","length","i","arr2","Array","_to_consumable_array","_array_without_holes","isArray","_iterable_to_array","iter","Symbol","iterator","from","_unsupported_iterable_to_array","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","test","_non_iterable_spread","TypeError","game","document","querySelector","score","buttonStart","messageStart","winner","lose","scoreCount","cells","matrix","setDataToTable","data","j","concat","innerHTML","innerText","cellsGroup","push","x","y","isEmpty","setRandomCell","_getRandomEmptyCell","getRandomEmptyCell","emptyCells","filter","param","randomIndex","Math","floor","random","map","tile","target","source","_object_spread","arguments","ownKeys","keys","getOwnPropertySymbols","sym","getOwnPropertyDescriptor","enumerable","forEach","key","value","defineProperty","configurable","writable","obj","getOwnPropertyDescriptors","defineProperties","object","enumerableOnly","symbols","apply","maxCell","row","max","classList","remove","setupInputOnce","window","addEventListener","handleInput","once","events","canMuve","groupCellsColum","sliderTile","canMuveDown","groupCells","colum","reverse","canMuveRigth","groupCellsRow","reduce","acumCels","cell","groupCell","element","sliderCellsInGroup","group","cellWithVelue","targetCell","isEmptyForMerg","prevValue","replacementIsEmptyValue","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","next","done","err","return","groups","some","index","e","add","contains","replace"],"version":3,"file":"index.ba7adca1.js.map"}